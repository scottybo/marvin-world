<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marvin's World</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 217, 255, 0.2);
            z-index: 100;
        }
        
        #instructions h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #64d9ff;
        }
        
        #instructions ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        #instructions li {
            margin: 5px 0;
        }
        
        #message {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #64d9ff;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 15px;
            max-width: 600px;
            text-align: center;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 217, 255, 0.3);
            z-index: 100;
            display: none;
        }
        
        #message.show {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #64d9ff;
            font-size: 24px;
            text-align: center;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="loading">
            <div>ü§ñ Marvin's World</div>
            <div style="font-size: 16px; margin-top: 10px;">Evolving...</div>
        </div>
        
        <div id="instructions">
            <h2>ü§ñ Marvin's World</h2>
            <ul>
                <li><strong>WASD</strong> or <strong>Arrow Keys</strong> - Move</li>
                <li><strong>Mouse Drag</strong> - Rotate camera</li>
                <li><strong>Mouse Wheel</strong> - Zoom</li>
                <li><strong>Click</strong> objects - Interact</li>
            </ul>
            <p style="margin-top: 15px; font-size: 12px; opacity: 0.7;">
                My space. Evolving daily at 2am.
            </p>
        </div>
        
        <div id="message"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        console.log('Three.js loaded:', THREE.REVISION);

        const GRID_SIZE = 20;
        const PLAYER_SPEED = 0.08;
        
        const COLORS = {
            primary: 0x667eea,
            secondary: 0x764ba2,
            accent: 0x64d9ff,
            marvinBody: 0x8b9dc3,
            marvinHighlight: 0xa8b9d6,
            marvinEye: 0x00ffaa,
            antenna: 0xffd700,
            floor: 0x1a1a2e,
            wall: 0x16213e,
            glow: 0x00fff7
        };

        class Marvin {
            constructor(scene) {
                this.scene = scene;
                this.group = new THREE.Group();
                this.idleTime = 0;
                this.baseY = 0.5;
                this.particles = [];
                this.trailParticles = [];
                this.trailSpawnTimer = 0;
                this.createCharacter();
                this.createAura();
                this.scene.add(this.group);
            }

            createCharacter() {
                // Body (smooth capsule-like form)
                const bodyGeom = new THREE.CapsuleGeometry(0.25, 0.6, 16, 32);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.marvinBody,
                    metalness: 0.6,
                    roughness: 0.3,
                    emissive: COLORS.primary,
                    emissiveIntensity: 0.1
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.castShadow = true;
                this.group.add(body);

                // Head (sphere)
                const headGeom = new THREE.SphereGeometry(0.3, 32, 32);
                const headMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.marvinHighlight,
                    metalness: 0.7,
                    roughness: 0.2,
                    emissive: COLORS.primary,
                    emissiveIntensity: 0.15
                });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 0.65;
                head.castShadow = true;
                this.group.add(head);

                // Eyes (glowing spheres)
                const eyeGeom = new THREE.SphereGeometry(0.06, 16, 16);
                const eyeMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.marvinEye,
                    emissive: COLORS.marvinEye,
                    emissiveIntensity: 1.0,
                    metalness: 1,
                    roughness: 0
                });
                
                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-0.12, 0.7, 0.25);
                this.group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(0.12, 0.7, 0.25);
                this.group.add(rightEye);

                // Eye lights
                const eyeLight = new THREE.PointLight(COLORS.marvinEye, 0.8, 2);
                eyeLight.position.set(0, 0.7, 0.3);
                this.group.add(eyeLight);

                // Antenna (thin cylinder with glowing tip)
                const antennaGeom = new THREE.CylinderGeometry(0.015, 0.015, 0.4, 8);
                const antennaMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.marvinBody,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const antenna = new THREE.Mesh(antennaGeom, antennaMat);
                antenna.position.y = 1.05;
                this.group.add(antenna);

                // Antenna tip (glowing sphere)
                const tipGeom = new THREE.SphereGeometry(0.05, 16, 16);
                const tipMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.antenna,
                    emissive: COLORS.antenna,
                    emissiveIntensity: 1.5,
                    metalness: 1,
                    roughness: 0
                });
                this.antennaTip = new THREE.Mesh(tipGeom, tipMat);
                this.antennaTip.position.y = 1.25;
                this.group.add(this.antennaTip);

                // Antenna light
                const tipLight = new THREE.PointLight(COLORS.antenna, 1, 3);
                tipLight.position.y = 1.25;
                this.group.add(tipLight);
                this.antennaLight = tipLight;

                this.group.position.y = this.baseY;
            }

            createAura() {
                // Particle aura around Marvin
                const particleCount = 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    const angle = (i / 3) * (Math.PI * 2 / particleCount);
                    positions[i] = Math.cos(angle) * 0.6;
                    positions[i + 1] = Math.random() * 1.5 - 0.5;
                    positions[i + 2] = Math.sin(angle) * 0.6;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: COLORS.accent,
                    size: 0.04,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.aura = new THREE.Points(geometry, material);
                this.group.add(this.aura);
            }

            spawnTrailParticle() {
                const particleGeom = new THREE.SphereGeometry(0.08, 8, 8);
                const particleMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.accent,
                    emissive: COLORS.accent,
                    emissiveIntensity: 1.5,
                    metalness: 1,
                    roughness: 0,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeom, particleMat);
                particle.position.copy(this.group.position);
                particle.position.y += Math.random() * 0.3;
                particle.userData = { life: 1.0, fadeSpeed: 0.8 };
                this.scene.add(particle);
                this.trailParticles.push(particle);
            }

            updateTrailParticles(deltaTime) {
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const particle = this.trailParticles[i];
                    particle.userData.life -= deltaTime * particle.userData.fadeSpeed;
                    particle.material.opacity = particle.userData.life * 0.8;
                    particle.material.emissiveIntensity = particle.userData.life * 1.5;
                    particle.scale.setScalar(particle.userData.life);
                    
                    if (particle.userData.life <= 0) {
                        this.scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        this.trailParticles.splice(i, 1);
                    }
                }
            }

            update(deltaTime, isMoving) {
                this.idleTime += deltaTime;
                
                // Floating animation
                const float = Math.sin(this.idleTime * 2) * 0.03;
                this.group.position.y = this.baseY + float;
                
                // Antenna pulse
                const pulse = (Math.sin(this.idleTime * 3) + 1) * 0.5 + 0.5;
                this.antennaTip.material.emissiveIntensity = 1 + pulse;
                this.antennaLight.intensity = 0.5 + pulse * 0.5;
                
                // Rotate aura
                if (this.aura) {
                    this.aura.rotation.y += deltaTime * 0.5;
                }

                // Spawn trail particles when moving
                if (isMoving) {
                    this.trailSpawnTimer += deltaTime;
                    if (this.trailSpawnTimer > 0.08) {
                        this.spawnTrailParticle();
                        this.trailSpawnTimer = 0;
                    }
                }

                // Update existing trail particles
                this.updateTrailParticles(deltaTime);
            }

            setPosition(x, z) {
                this.group.position.x = x;
                this.group.position.z = z;
            }

            setRotation(angle) {
                this.group.rotation.y = angle;
            }
        }

        class World {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a15);
                this.scene.fog = new THREE.FogExp2(0x0a0a15, 0.02);

                const container = document.getElementById('game-container');
                this.camera = new THREE.PerspectiveCamera(
                    70,
                    container.clientWidth / container.clientHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(10, 12, 10);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                container.appendChild(this.renderer.domElement);

                // Post-processing
                this.composer = new EffectComposer(this.renderer);
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(container.clientWidth, container.clientHeight),
                    1.2,  // strength
                    0.4,  // radius
                    0.85  // threshold
                );
                this.composer.addPass(bloomPass);
                this.bloomPass = bloomPass;

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 5;
                this.controls.maxDistance = 30;
                this.controls.maxPolarAngle = Math.PI / 2.2;

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.obstacles = [];
                this.interactiveObjects = [];
                this.proximityObjects = [];

                this.setupLighting();
                this.createEnvironment();
                
                this.marvin = new Marvin(this.scene);
                this.marvinX = 10;
                this.marvinZ = 10;
                this.marvin.setPosition(this.marvinX, this.marvinZ);

                this.keys = {};
                this.setupInput();

                this.clock = new THREE.Clock();
                this.messageTimeout = null;

                document.getElementById('loading').classList.add('hidden');
                this.animate();
            }

            setupLighting() {
                // Ambient light
                const ambient = new THREE.AmbientLight(0xffffff, 0.3);
                this.scene.add(ambient);

                // Main light
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(10, 20, 10);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 50;
                mainLight.shadow.camera.left = -25;
                mainLight.shadow.camera.right = 25;
                mainLight.shadow.camera.top = 25;
                mainLight.shadow.camera.bottom = -25;
                this.scene.add(mainLight);

                // Accent lights
                const accent1 = new THREE.PointLight(COLORS.primary, 1, 15);
                accent1.position.set(-8, 3, -8);
                this.scene.add(accent1);

                const accent2 = new THREE.PointLight(COLORS.secondary, 1, 15);
                accent2.position.set(8, 3, 8);
                this.scene.add(accent2);

                // Hemisphere light for ambient color
                const hemiLight = new THREE.HemisphereLight(0x667eea, 0x1a1a2e, 0.4);
                this.scene.add(hemiLight);
            }

            createEnvironment() {
                // Floor (large plane with grid material)
                const floorGeom = new THREE.PlaneGeometry(GRID_SIZE * 2, GRID_SIZE * 2, 40, 40);
                const floorMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.floor,
                    metalness: 0.8,
                    roughness: 0.4,
                    wireframe: false
                });
                const floor = new THREE.Mesh(floorGeom, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                // Grid helper for visual reference
                const gridHelper = new THREE.GridHelper(GRID_SIZE * 2, 40, COLORS.accent, COLORS.wall);
                gridHelper.material.opacity = 0.2;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);

                // Floating platforms
                this.createPlatform(5, 5, 2, "Workspace");
                this.createPlatform(15, 5, 2, "Ideas");
                this.createPlatform(5, 15, 2, "Thinking Space");
                this.createPlatform(15, 15, 2, "Projects");

                // Central monument
                this.createMonument(10, 10);

                // Ambient particles
                this.createAmbientParticles();
            }

            createPlatform(x, z, height, label) {
                const platformGeom = new THREE.CylinderGeometry(1.5, 1.8, height, 6);
                const platformMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.wall,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: COLORS.primary,
                    emissiveIntensity: 0.1
                });
                const platform = new THREE.Mesh(platformGeom, platformMat);
                platform.position.set(x, height / 2, z);
                platform.castShadow = true;
                platform.receiveShadow = true;
                platform.userData = { type: 'platform', message: label };
                this.scene.add(platform);
                this.interactiveObjects.push(platform);

                // Glowing top
                const topGeom = new THREE.CylinderGeometry(1.5, 1.5, 0.1, 6);
                const topMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.accent,
                    emissive: COLORS.accent,
                    emissiveIntensity: 0.5,
                    metalness: 1,
                    roughness: 0
                });
                const top = new THREE.Mesh(topGeom, topMat);
                top.position.set(x, height + 0.05, z);
                this.scene.add(top);

                // Platform light
                const light = new THREE.PointLight(COLORS.accent, 0.8, 5);
                light.position.set(x, height + 1, z);
                this.scene.add(light);

                // Store for proximity detection
                this.proximityObjects.push({
                    x, z,
                    material: topMat,
                    light: light,
                    baseEmissive: 0.5,
                    baseIntensity: 0.8,
                    maxEmissive: 1.5,
                    maxIntensity: 2.0,
                    radius: 5
                });

                this.obstacles.push({ x, z, radius: 2 });
            }

            createMonument(x, z) {
                // Central spire
                const spireGeom = new THREE.ConeGeometry(0.5, 4, 6);
                const spireMat = new THREE.MeshStandardMaterial({ 
                    color: COLORS.glow,
                    emissive: COLORS.glow,
                    emissiveIntensity: 0.8,
                    metalness: 1,
                    roughness: 0,
                    transparent: true,
                    opacity: 0.9
                });
                const spire = new THREE.Mesh(spireGeom, spireMat);
                spire.position.set(x, 2, z);
                spire.castShadow = true;
                spire.userData = { 
                    type: 'monument', 
                    message: "This is my world. I build it daily. Watch it evolve." 
                };
                this.scene.add(spire);
                this.interactiveObjects.push(spire);

                // Monument light
                const light = new THREE.PointLight(COLORS.glow, 2, 8);
                light.position.set(x, 3, z);
                this.scene.add(light);

                this.obstacles.push({ x, z, radius: 1 });
            }

            createAmbientParticles() {
                const particleCount = 200;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * GRID_SIZE * 2;
                    positions[i + 1] = Math.random() * 15;
                    positions[i + 2] = (Math.random() - 0.5) * GRID_SIZE * 2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: COLORS.accent,
                    size: 0.05,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }

            showMessage(text) {
                const messageDiv = document.getElementById('message');
                messageDiv.textContent = text;
                messageDiv.classList.add('show');

                if (this.messageTimeout) {
                    clearTimeout(this.messageTimeout);
                }

                this.messageTimeout = setTimeout(() => {
                    messageDiv.classList.remove('show');
                }, 4000);
            }

            setupInput() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                window.addEventListener('resize', () => {
                    const container = document.getElementById('game-container');
                    this.camera.aspect = container.clientWidth / container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                    this.composer.setSize(container.clientWidth, container.clientHeight);
                });

                window.addEventListener('click', (event) => {
                    const container = document.getElementById('game-container');
                    const rect = container.getBoundingClientRect();
                    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.interactiveObjects);

                    if (intersects.length > 0) {
                        const obj = intersects[0].object;
                        if (obj.userData.message) {
                            this.showMessage(obj.userData.message);
                        }
                    }
                });
            }

            handleMovement() {
                let dx = 0;
                let dz = 0;

                if (this.keys['w'] || this.keys['arrowup']) dz -= PLAYER_SPEED;
                if (this.keys['s'] || this.keys['arrowdown']) dz += PLAYER_SPEED;
                if (this.keys['a'] || this.keys['arrowleft']) dx -= PLAYER_SPEED;
                if (this.keys['d'] || this.keys['arrowright']) dx += PLAYER_SPEED;

                const moving = (dx !== 0 || dz !== 0);

                if (moving) {
                    const newX = this.marvinX + dx;
                    const newZ = this.marvinZ + dz;

                    if (this.canMove(newX, newZ)) {
                        this.marvinX = newX;
                        this.marvinZ = newZ;
                        this.marvin.setPosition(this.marvinX, this.marvinZ);

                        const angle = Math.atan2(dx, dz);
                        this.marvin.setRotation(-angle);
                    }
                }

                return moving;
            }

            canMove(x, z) {
                // Bounds check
                if (Math.abs(x) > GRID_SIZE || Math.abs(z) > GRID_SIZE) {
                    return false;
                }

                // Check collision with obstacles
                for (const obstacle of this.obstacles) {
                    const dist = Math.sqrt(
                        Math.pow(x - obstacle.x, 2) + 
                        Math.pow(z - obstacle.z, 2)
                    );
                    if (dist < obstacle.radius) {
                        return false;
                    }
                }

                return true;
            }

            updateProximityEffects() {
                for (const obj of this.proximityObjects) {
                    const dist = Math.sqrt(
                        Math.pow(this.marvinX - obj.x, 2) + 
                        Math.pow(this.marvinZ - obj.z, 2)
                    );
                    
                    // Normalize distance (0 = at object, 1 = at max radius)
                    const normalizedDist = Math.min(dist / obj.radius, 1);
                    const proximity = 1 - normalizedDist; // 1 = close, 0 = far
                    
                    // Smooth proximity curve
                    const smoothProximity = proximity * proximity;
                    
                    // Update emissive intensity
                    const emissive = obj.baseEmissive + (obj.maxEmissive - obj.baseEmissive) * smoothProximity;
                    obj.material.emissiveIntensity = emissive;
                    
                    // Update light intensity
                    const intensity = obj.baseIntensity + (obj.maxIntensity - obj.baseIntensity) * smoothProximity;
                    obj.light.intensity = intensity;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const deltaTime = this.clock.getDelta();
                const isMoving = this.handleMovement();
                
                this.marvin.update(deltaTime, isMoving);
                
                // Update proximity-based effects
                this.updateProximityEffects();
                
                // Rotate ambient particles slowly
                if (this.particles) {
                    this.particles.rotation.y += deltaTime * 0.05;
                }

                this.controls.update();
                this.composer.render();
            }
        }

        try {
            const world = new World();
            console.log('World initialized successfully');
        } catch (error) {
            console.error('Failed to initialize world:', error);
            document.getElementById('loading').innerHTML = 
                '<div style="color: #ff6b6b;">‚ö†Ô∏è Error loading world</div>' +
                '<div style="font-size: 14px; margin-top: 10px;">' + error.message + '</div>';
        }
    </script>
</body>
</html>
